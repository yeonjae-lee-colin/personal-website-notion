"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
exports.__esModule = true;
var react_1 = require("react");
var react_2 = require("@testing-library/react");
var index_1 = __importDefault(require("./index"));
describe('mergeRefs()', function () {
    it('returns falsy result given no arguments', function () {
        var result = (0, index_1["default"])();
        expect(result).toBe(undefined);
    });
    it('returns falsy result given falsy arguments', function () {
        var result = (0, index_1["default"])(null, null);
        expect(result).toBe(undefined);
    });
    it('returns original ref given only one ref', function () {
        var ref = jest.fn();
        var result = (0, index_1["default"])(ref);
        expect(result).toBe(ref);
    });
    it('returns original ref given one ref and one falsy argument', function () {
        var ref = jest.fn();
        var result = (0, index_1["default"])(ref, null);
        expect(result).toBe(ref);
    });
    it('returns merged refs properly', function () {
        var ref1 = jest.fn();
        var ref2 = (0, react_1.createRef)();
        var result = (0, index_1["default"])(ref1, ref2);
        expect(result).not.toBe(ref1);
        expect(result).toEqual(expect.any(Function));
    });
    it('handles merged functional refs properly', function () {
        var ref1 = jest.fn();
        var ref2 = (0, react_1.createRef)();
        var mergedRef = (0, index_1["default"])(ref1, ref2);
        var container = (0, react_2.render)(<div ref={mergedRef}/>).container;
        expect(ref1).toHaveBeenCalledTimes(1);
        expect(ref1).toHaveBeenCalledWith(container.firstChild);
    });
    it('handles merged object refs properly', function () {
        var ref1 = (0, react_1.createRef)();
        var ref2 = jest.fn();
        var mergedRef = (0, index_1["default"])(ref1, ref2);
        var container = (0, react_2.render)(<div ref={mergedRef}/>).container;
        expect(ref1.current).toBe(container.firstChild);
    });
});
